const fs = require('fs');
const path = require('path');
const PDFDocument = require('pdfkit');
const { v4: uuidv4 } = require('uuid');

function ensureDir(dir) {
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }
}

async function generatePdf(audit, forcedPath) {
  const reportDir = process.env.REPORT_DIR || path.join(__dirname, '..', 'storage', 'reports');
  ensureDir(reportDir);
  const fileName = forcedPath ? path.basename(forcedPath) : `audit-${uuidv4()}.pdf`;
  const filePath = forcedPath ? forcedPath : path.join(reportDir, fileName);

  const doc = new PDFDocument({ margin: 36 });
  const writeStream = fs.createWriteStream(filePath);
  doc.pipe(writeStream);

  // Header
  doc.fontSize(18).text('Website Audit Report', { underline: true });
  doc.moveDown();
  doc.fontSize(12).text(`URL: ${audit.url}`);
  doc.text(`Status: ${audit.status}`);
  doc.text(`Created: ${audit.createdAt ? new Date(audit.createdAt).toISOString() : ''}`);
  doc.moveDown();

  // Crawl data
  const crawl = audit.crawlData || {};
  doc.fontSize(14).text('Crawl Data');
  doc.fontSize(12).text(`Title: ${crawl.title || 'N/A'}`);
  doc.text(`Meta Description: ${crawl.metaDescription || 'N/A'}`);
  if (crawl.h1Headings?.length) {
    doc.text('H1 Headings:');
    crawl.h1Headings.slice(0, 10).forEach((h1, idx) => doc.text(`  ${idx + 1}. ${h1}`));
  } else {
    doc.text('H1 Headings: None found');
  }
  doc.moveDown();

  // Lighthouse scores
  if (audit.lighthouse?.scores) {
    const s = audit.lighthouse.scores;
    doc.fontSize(14).text('Lighthouse Scores');
    doc.fontSize(12).text(`Performance: ${s.performance}`);
    doc.text(`Accessibility: ${s.accessibility}`);
    doc.text(`Best Practices: ${s.bestPractices}`);
    doc.text(`SEO: ${s.seo}`);
    doc.moveDown();
  }

  // AI Summary
  if (audit.aiSummary?.summary) {
    doc.fontSize(14).text('AI Summary');
    doc.fontSize(12).text(audit.aiSummary.summary);
    doc.moveDown();
  }

  // AI Recommendations
  if (audit.aiSummary?.recommendations?.length) {
    doc.fontSize(14).text('Recommendations');
    audit.aiSummary.recommendations.slice(0, 10).forEach((rec, idx) => {
      doc.fontSize(12).text(`- ${rec}`);
    });
    doc.moveDown();
  }

  doc.fontSize(10).fillColor('gray').text('Generated by ai-website-audit tool.');
  doc.end();

  await new Promise((resolve, reject) => {
    writeStream.on('finish', resolve);
    writeStream.on('error', reject);
  });

  return filePath;
}

// alias for compatibility
async function generatePDF(audit, filePath) {
  return generatePdf(audit, filePath);
}

module.exports = { generatePdf, generatePDF };

